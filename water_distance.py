# coding: utf-8
import sys
sys.path.append('.')
import os

import json

from pydmga.geometry import OrthogonalGeometry
from pydmga.container import Container
from pydmga.diagram import Diagram
from pydmga.io import pdb
from pydmga.io import helper
import traceback

from pydmga.draw import assets
from pydmga.draw import render
from pydmga.draw.render import Asset
from pydmga.draw.render import Color

from math import pi
from math import sqrt
from math import cos
from math import sin
from math import acos
from math import asin

import numpy as np

###############################################################
# REAL SCRIPT STARTS HERE #####################################
###############################################################

# TODO: Dipol angle (lists per time + sensowny histogram)
# TODO: Save layer as a .ndx file (each frame as a single group?), to be able to recover layers
# TODO: save neighbours list in TXT readable file for later analysis and/or speed up?
# TODO: rethink computation of following layers by providing .ndx file (one entry per frame), so that
#       we can use .ndx files generated by one run for base molecules to compute next layers
#       in case of a single group in .ndx use it for all frames (handy for base molecules around which water flows)

# # IMPORT SETTINGS
if (len(sys.argv) < 2):
	print "Computes statistics on the water-molecule distance (all atoms)"
	print "NOTE: Requires running compute3d.py first."
	print ""
	print "Usage: python water_distance.py [path.to.conf]"
	print ""
	print "  [path.to.conf] is a python module path to a file containing configuration.";
	print "                 see sample files in jobs/* for reference."
	sys.exit(-1)

job = helper.Job(sys.argv, app="water_distance")

molecules = {
	'chol': {
		'def': {
			'lo': 1,
			'up': 74,
			'plane_atoms_ids': [9, 18, 35],
			# we fit consecutive MOLECULES of this type to this atoms 
			# we want:
			# a) all atoms on the same plane
			# b) line from plane_atoms_ids[1] to plane_atoms_ids[2] on time t-1 be on the line at t )
			# c) position of plane_atoms_ids[2] on t-1 the same as in t)
		},
	},
}
try: molecules = job.settings.MOLECULES; 
except: job.log("# WARNING: using default MOLECULES (CHOL) = {}\n".format(str(molecules)))

for key, moldata in molecules.iteritems():
	if "ndx" not in moldata:
		if "def" in moldata:
			moldata["ndx"] = list(range(moldata['def']["lo"], moldata['def']["up"] + 1))
		else:
			raise Exception("You must specify either 'def' or 'ndx' for '{}' in settings.".format(key))

# generate as many analysis files as there are different kinds of molecules in the setup
for molecule_key in molecules:		
	distances_analys_file = job.user_file("{molecule_key}_{app}_water_distances_all_analys.dat", {"molecule_key": molecule_key})
	distances_analys_file.write(job.info)
	distances_analys_file.write("# LEGEND: \n")
	distances_analys_file.write("# time frame              obvious\n")
	distances_analys_file.write("# avg,std,min,max[dist]   statistics on the distance to molecule partners for that time\n")
	distances_analys_file.write("# \n")
	distances_analys_file.write("# This file was generated for job '{}' and molecule: '{}'\n".format(job.jobname, molecule_key))
	distances_analys_file.write("# \n")
	distances_analys_file.write("# Header numbers for help in gnuplot! \n")
	distances_analys_file.write("# 1    2     3       4       5       6      \n")
	distances_analys_file.write("# time frame avgdist stddist mindist maxdist\n")	
	molecules[molecule_key]['distances_analys_file'] = distances_analys_file		

water_molecules_file = file(job.filepath("compute3d_water_molecules.json"), mode="r")
water_molecules = json.load(water_molecules_file)
water_molecules_file.close()


for molecule_key, moldata in molecules.iteritems():	
	positions_file = file(job.filepath("compute3d_positions.tjson"), mode="r")
	water_neighbours_file = file(job.filepath("{molecule_key}_compute3d_water_neighbours.tjson", {"molecule_key": molecule_key}), mode="r")
	frame = 0
	for water_nb_line in water_neighbours_file:
		this_frame_angles = []
		this_frame_distances = []
		positions_line = positions_file.readline()
		time, waters = water_nb_line.strip().split(" ", 1)
		_, positions = positions_line.strip().split(" ", 1)
		positions = json.loads(positions)
		waters = json.loads(waters)
		for oxg_id, nb_list in waters.iteritems():
			selected = []
			for other_id, (dist, area) in nb_list.iteritems():
				this_frame_distances.append(dist)		

		moldata["distances_analys_file"].write("{} {} {} {} {} {}\n".format(
			time,
			frame,
			np.mean(this_frame_distances),
			np.std(this_frame_distances),
			min(this_frame_distances),
			max(this_frame_distances),
		))		

	water_neighbours_file.close()
	positions_file.close()

job.finish("Finished normally")